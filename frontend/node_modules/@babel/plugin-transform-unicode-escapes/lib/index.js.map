{"version":3,"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","surrogate","unicodeEscape","escape","code","str","toString","length","replacer","match","backslashes","char","String","fromCodePoint","parseInt","escaped","slice","charCodeAt","replaceUnicodeEscapes","replace","getUnicodeEscape","exec","lastIndex","name","manipulateOptions","generatorOpts","_generatorOpts$jsescO","_generatorOpts$jsescO2","jsescOption","minimal","visitor","Identifier","path","node","key","replaced","c","t","inherits","stringLiteral","replaceWith","parentPath","scope","isMemberExpression","property","isOptionalMemberExpression","computed","binding","getBinding","rename","generateUid","buildCodeFrameError","StringLiteral|DirectiveLiteral","extra","raw","TemplateElement","value","firstEscape","grandParent","isTaggedTemplateExpression"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, type NodePath } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const surrogate = /[\\ud800-\\udfff]/g;\n  const unicodeEscape = /(\\\\+)u\\{([0-9a-fA-F]+)\\}/g;\n\n  function escape(code: number) {\n    if (process.env.BABEL_8_BREAKING) {\n      return \"\\\\u\" + code.toString(16).padStart(4, \"0\");\n    } else {\n      let str = code.toString(16);\n      while (str.length < 4) str = \"0\" + str;\n      return \"\\\\u\" + str;\n    }\n  }\n\n  function replacer(match: string, backslashes: string, code: string) {\n    if (backslashes.length % 2 === 0) {\n      return match;\n    }\n\n    const char = String.fromCodePoint(parseInt(code, 16));\n    const escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));\n\n    return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));\n  }\n\n  function replaceUnicodeEscapes(str: string) {\n    return str.replace(unicodeEscape, replacer);\n  }\n\n  function getUnicodeEscape(str: string) {\n    let match;\n    while ((match = unicodeEscape.exec(str))) {\n      if (match[1].length % 2 === 0) continue;\n      unicodeEscape.lastIndex = 0;\n      return match[0];\n    }\n    return null;\n  }\n\n  return {\n    name: \"transform-unicode-escapes\",\n    manipulateOptions({ generatorOpts }) {\n      // Babel 8 will enable jsesc minimal mode by default, which outputs\n      // unescaped unicode string\n      if (!generatorOpts.jsescOption) {\n        generatorOpts.jsescOption = {};\n      }\n      generatorOpts.jsescOption.minimal ??= false;\n    },\n    visitor: {\n      Identifier(path) {\n        const { node, key } = path;\n        const { name } = node;\n        const replaced = name.replace(surrogate, c => {\n          return `_u${c.charCodeAt(0).toString(16)}`;\n        });\n        if (name === replaced) return;\n\n        const str = t.inherits(t.stringLiteral(name), node);\n\n        if (key === \"key\") {\n          path.replaceWith(str);\n          return;\n        }\n\n        const { parentPath, scope } = path;\n        if (\n          parentPath.isMemberExpression({ property: node }) ||\n          parentPath.isOptionalMemberExpression({ property: node })\n        ) {\n          parentPath.node.computed = true;\n          path.replaceWith(str);\n          return;\n        }\n\n        const binding = scope.getBinding(name);\n        if (binding) {\n          scope.rename(name, scope.generateUid(replaced));\n          return;\n        }\n\n        throw path.buildCodeFrameError(\n          `Can't reference '${name}' as a bare identifier`,\n        );\n      },\n\n      \"StringLiteral|DirectiveLiteral\"(\n        path: NodePath<t.StringLiteral | t.DirectiveLiteral>,\n      ) {\n        const { node } = path;\n        const { extra } = node;\n\n        if (extra?.raw) extra.raw = replaceUnicodeEscapes(extra.raw as string);\n      },\n\n      TemplateElement(path) {\n        const { node, parentPath } = path;\n        const { value } = node;\n\n        const firstEscape = getUnicodeEscape(value.raw);\n        if (!firstEscape) return;\n\n        const grandParent = parentPath.parentPath;\n        if (grandParent.isTaggedTemplateExpression()) {\n          throw path.buildCodeFrameError(\n            `Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`,\n          );\n        }\n\n        value.raw = replaceUnicodeEscapes(value.raw);\n      },\n    },\n  };\n});\n"],"mappings":"